If you should remember only one key thing from this article, it should be following relation between modular congruence and Lattice:

> For given congruence:   
>
> $y \equiv Ax (mod B)$
> 
> All points (x, y) lay on Lattice generated by basis vectors:  
> 
> $\overrightarrow{(1,A)} + k\overrightarrow{(0,B)}$
> 
>
>> $y \equiv Ax (mod B)$   
>> can we rewrite as:  
>> $y-Ax = kB$  
>> $y = A x + kB$   
>> So every solution has the form:  
>> $(x, y) = (x, A x + kB)$    
>> or:   
>> $(x,y) = x,\overrightarrow{(1,A)} + k\overrightarrow{(0,B)}$
>
> Here is graphical example for A = 2, B = 5
> ![](/img/knapsack1.png)  

And now back to our knapsack cryptosystem.  
Whar we know?  
We know only public key N = [661, 437, 45, 807, 617, 719, 822]  
and encrypted message c = 2145    
But we also know that values in list N are modular congruencies of private key M:  
$n_1 \equiv Am_1(mod B)$   
$n_2 \equiv Am_2(mod B)$   
$n_3 \equiv Am_3(mod B)$   
$n_4 \equiv Am_4(mod B)$   
$n_5 \equiv Am_5(mod B)$   
$n_6 \equiv Am_6(mod B)$   
$n_7 \equiv Am_7(mod B)$   

These congruencies gives us certain points on Lattice. Each congruence in one dimension. These point defines basis vectors - each row, one vector.  
$(x,y) = m_i, 
